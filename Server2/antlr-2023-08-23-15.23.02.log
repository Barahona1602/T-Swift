2023-08-23 15:22:55:863 grammar LogManager.java:25 before: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE VOID (BLOCK (ALT 'void'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MOD (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-23 15:22:55:999 grammar LogManager.java:25 after: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE VOID (BLOCK (ALT 'void'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MOD (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 15:23:01:979 grammar LogManager.java:25 before: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE block2 (returns []interface{} blk2) (@ init {
    $blk2 = []interface{}{}
    var listInt []IInstructionContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
    listInt = localctx.(*Block2Context).GetIns()
    for _, e := range listInt {
        $blk2 = append($blk2, e.GetInst())
    }
}))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT whilestmt { $inst = $whilestmt.whl }) (ALT breakstmt { $inst = $breakstmt.brk }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE LLAVEIZQ block2 LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, $block2.blk2) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE ifstmt { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, []interface{}{$ifstmt.ifinst}) }))) (RULE whilestmt (returns interfaces.Instruction whl) (BLOCK (ALT WHILE expr LLAVEIZQ block2 LLAVEDER { $whl = instructions.NewWhile($WHILE.line, $WHILE.pos, $expr.e, $block2.blk2) }))) (RULE breakstmt (returns interfaces.Instruction brk) (BLOCK (ALT BREAK expr { $brk = instructions.NewBreak($BREAK.line, $BREAK.pos, $expression.p) }) (ALT BREAK { $brk = instructions.NewBreak($BREAK.line, $BREAK.pos, nil) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-23 15:23:01:992 grammar LogManager.java:25 after: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE block2 (returns []interface{} blk2) (@ init {
    $blk2 = []interface{}{}
    var listInt []IInstructionContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
    listInt = localctx.(*Block2Context).GetIns()
    for _, e := range listInt {
        $blk2 = append($blk2, e.GetInst())
    }
}))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT whilestmt { $inst = $whilestmt.whl }) (ALT breakstmt { $inst = $breakstmt.brk }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE LLAVEIZQ block2 LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, $block2.blk2) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE ifstmt { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, []interface{}{$ifstmt.ifinst}) }))) (RULE whilestmt (returns interfaces.Instruction whl) (BLOCK (ALT WHILE expr LLAVEIZQ block2 LLAVEDER { $whl = instructions.NewWhile($WHILE.line, $WHILE.pos, $expr.e, $block2.blk2) }))) (RULE breakstmt (returns interfaces.Instruction brk) (BLOCK (ALT BREAK expr { $brk = instructions.NewBreak($BREAK.line, $BREAK.pos, $expression.p) }) (ALT BREAK { $brk = instructions.NewBreak($BREAK.line, $BREAK.pos, nil) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-23 15:23:02:002 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE block2 (returns []interface{} blk2) (@ init {
    $blk2 = []interface{}{}
    var listInt []IInstructionContext
}) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
    listInt = localctx.(*Block2Context).GetIns()
    for _, e := range listInt {
        $blk2 = append($blk2, e.GetInst())
    }
}))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT whilestmt { $inst = $whilestmt.whl }) (ALT breakstmt { $inst = $breakstmt.brk }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE LLAVEIZQ block2 LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, $block2.blk2) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE ifstmt { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, []interface{}{$ifstmt.ifinst}) }))) (RULE whilestmt (returns interfaces.Instruction whl) (BLOCK (ALT WHILE expr LLAVEIZQ block2 LLAVEDER { $whl = instructions.NewWhile($WHILE.line, $WHILE.pos, $expr.e, $block2.blk2) }))) (RULE breakstmt (returns interfaces.Instruction brk) (BLOCK (ALT BREAK expr { $brk = instructions.NewBreak($BREAK.line, $BREAK.pos, $expression.p) }) (ALT BREAK { $brk = instructions.NewBreak($BREAK.line, $BREAK.pos, nil) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-23 15:23:02:002 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftGrammarLexer OPTIONS (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) RULES)
2023-08-23 15:23:02:127 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} PARIZQ<tokenIndex=448> expr<tokenIndex=450> PARDER<tokenIndex=452> { $e = $expr.e } 
        | list=listArray<tokenIndex=460> { $e = $list.p} 
        | CORIZQ<tokenIndex=466> listParams<tokenIndex=468> CORDER<tokenIndex=470> { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) } 
        | NUMBER<tokenIndex=476>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=482>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRU<tokenIndex=488> { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) } 
        | FAL<tokenIndex=494> { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=(MUL<tokenIndex=323>|DIV<tokenIndex=325>) right=expr<tokenIndex=330,p=15> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=(ADD<tokenIndex=343>|SUB<tokenIndex=345>) right=expr<tokenIndex=350,p=14> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> op=(MAY_IG<tokenIndex=363>|MAYOR<tokenIndex=365>) right=expr<tokenIndex=370,p=13> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> op=(MEN_IG<tokenIndex=383>|MENOR<tokenIndex=385>) right=expr<tokenIndex=390,p=12> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> op=(IG_IG<tokenIndex=403>|DIF<tokenIndex=405>) right=expr<tokenIndex=410,p=11> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 9)}?<p=9> op=AND<tokenIndex=422> right=expr<tokenIndex=426,p=10> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 8)}?<p=8> op=OR<tokenIndex=438> right=expr<tokenIndex=442,p=9> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-08-23 15:23:02:199 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 448))) (expr (ELEMENT_OPTIONS (= tokenIndex 450))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 452))) { $e = $expr.e }) (ALT (= list (listArray (ELEMENT_OPTIONS (= tokenIndex 460)))) { $e = $list.p}) (ALT (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 466))) (listParams (ELEMENT_OPTIONS (= tokenIndex 468))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 470))) { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 476))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 482))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRU (ELEMENT_OPTIONS (= tokenIndex 488))) { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT (FAL (ELEMENT_OPTIONS (= tokenIndex 494))) { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 323))) (DIV (ELEMENT_OPTIONS (= tokenIndex 325))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 330) (= p 15)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 343))) (SUB (ELEMENT_OPTIONS (= tokenIndex 345))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 350) (= p 14)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 363))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 365))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 370) (= p 13)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 383))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 385))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 390) (= p 12)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 403))) (DIF (ELEMENT_OPTIONS (= tokenIndex 405))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 410) (= p 11)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 9)}? (ELEMENT_OPTIONS (= p 9))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 422)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 426) (= p 10)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 8)}? (ELEMENT_OPTIONS (= p 8))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 438)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 442) (= p 9)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-08-23 15:23:02:200 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} expr<tokenIndex=519> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=511> expr<tokenIndex=513> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-08-23 15:23:02:231 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (expr (ELEMENT_OPTIONS (= tokenIndex 519))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 511))) (expr (ELEMENT_OPTIONS (= tokenIndex 513))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-08-23 15:23:02:242 left-recursion LogManager.java:25 listArray returns [interfaces.Expression p]
    :   ( {} ID<tokenIndex=548> { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> CORIZQ<tokenIndex=538> expr<tokenIndex=540> CORDER<tokenIndex=542> { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }
        )*
    ;
2023-08-23 15:23:02:261 grammar LogManager.java:25 added: (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 548))) { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 538))) (expr (ELEMENT_OPTIONS (= tokenIndex 540))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 542))) { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }))))))
2023-08-23 15:23:02:294 grammar LogManager.java:25 import INT=1
2023-08-23 15:23:02:295 grammar LogManager.java:25 import FLOAT=2
2023-08-23 15:23:02:295 grammar LogManager.java:25 import BOOL=3
2023-08-23 15:23:02:295 grammar LogManager.java:25 import STR=4
2023-08-23 15:23:02:295 grammar LogManager.java:25 import CHAR=5
2023-08-23 15:23:02:295 grammar LogManager.java:25 import VAR=6
2023-08-23 15:23:02:300 grammar LogManager.java:25 import LET=7
2023-08-23 15:23:02:300 grammar LogManager.java:25 import VOID=8
2023-08-23 15:23:02:300 grammar LogManager.java:25 import TRU=9
2023-08-23 15:23:02:300 grammar LogManager.java:25 import FAL=10
2023-08-23 15:23:02:300 grammar LogManager.java:25 import PRINT=11
2023-08-23 15:23:02:300 grammar LogManager.java:25 import IF=12
2023-08-23 15:23:02:300 grammar LogManager.java:25 import ELSE=13
2023-08-23 15:23:02:300 grammar LogManager.java:25 import WHILE=14
2023-08-23 15:23:02:300 grammar LogManager.java:25 import FOR=15
2023-08-23 15:23:02:300 grammar LogManager.java:25 import IN=16
2023-08-23 15:23:02:302 grammar LogManager.java:25 import SWITCH=17
2023-08-23 15:23:02:302 grammar LogManager.java:25 import CASE=18
2023-08-23 15:23:02:302 grammar LogManager.java:25 import DEFAULT=19
2023-08-23 15:23:02:303 grammar LogManager.java:25 import BREAK=20
2023-08-23 15:23:02:303 grammar LogManager.java:25 import RETURN=21
2023-08-23 15:23:02:306 grammar LogManager.java:25 import CONTINUE=22
2023-08-23 15:23:02:306 grammar LogManager.java:25 import GUARD=23
2023-08-23 15:23:02:306 grammar LogManager.java:25 import FUNC=24
2023-08-23 15:23:02:306 grammar LogManager.java:25 import NIL=25
2023-08-23 15:23:02:306 grammar LogManager.java:25 import STRUCT=26
2023-08-23 15:23:02:306 grammar LogManager.java:25 import MUTATING=27
2023-08-23 15:23:02:306 grammar LogManager.java:25 import SELF=28
2023-08-23 15:23:02:308 grammar LogManager.java:25 import INOUT=29
2023-08-23 15:23:02:309 grammar LogManager.java:25 import APPEND=30
2023-08-23 15:23:02:309 grammar LogManager.java:25 import REMOVELAST=31
2023-08-23 15:23:02:309 grammar LogManager.java:25 import REMOVE=32
2023-08-23 15:23:02:309 grammar LogManager.java:25 import AT=33
2023-08-23 15:23:02:309 grammar LogManager.java:25 import ISEMPTY=34
2023-08-23 15:23:02:309 grammar LogManager.java:25 import COUNT=35
2023-08-23 15:23:02:309 grammar LogManager.java:25 import NUMBER=36
2023-08-23 15:23:02:309 grammar LogManager.java:25 import STRING=37
2023-08-23 15:23:02:309 grammar LogManager.java:25 import ID=38
2023-08-23 15:23:02:309 grammar LogManager.java:25 import DIF=39
2023-08-23 15:23:02:310 grammar LogManager.java:25 import IG_IG=40
2023-08-23 15:23:02:310 grammar LogManager.java:25 import NOT=41
2023-08-23 15:23:02:310 grammar LogManager.java:25 import OR=42
2023-08-23 15:23:02:310 grammar LogManager.java:25 import AND=43
2023-08-23 15:23:02:310 grammar LogManager.java:25 import IG=44
2023-08-23 15:23:02:310 grammar LogManager.java:25 import MAY_IG=45
2023-08-23 15:23:02:310 grammar LogManager.java:25 import MEN_IG=46
2023-08-23 15:23:02:310 grammar LogManager.java:25 import MAYOR=47
2023-08-23 15:23:02:310 grammar LogManager.java:25 import MENOR=48
2023-08-23 15:23:02:310 grammar LogManager.java:25 import MUL=49
2023-08-23 15:23:02:310 grammar LogManager.java:25 import DIV=50
2023-08-23 15:23:02:310 grammar LogManager.java:25 import ADD=51
2023-08-23 15:23:02:312 grammar LogManager.java:25 import SUB=52
2023-08-23 15:23:02:312 grammar LogManager.java:25 import MOD=53
2023-08-23 15:23:02:312 grammar LogManager.java:25 import PARIZQ=54
2023-08-23 15:23:02:312 grammar LogManager.java:25 import PARDER=55
2023-08-23 15:23:02:312 grammar LogManager.java:25 import LLAVEIZQ=56
2023-08-23 15:23:02:312 grammar LogManager.java:25 import LLAVEDER=57
2023-08-23 15:23:02:312 grammar LogManager.java:25 import D_PTS=58
2023-08-23 15:23:02:312 grammar LogManager.java:25 import CORIZQ=59
2023-08-23 15:23:02:315 grammar LogManager.java:25 import CORDER=60
2023-08-23 15:23:02:315 grammar LogManager.java:25 import COMA=61
2023-08-23 15:23:02:315 grammar LogManager.java:25 import WHITESPACE=62
2023-08-23 15:23:02:315 grammar LogManager.java:25 import COMMENT=63
2023-08-23 15:23:02:315 grammar LogManager.java:25 import LINE_COMMENT=64
2023-08-23 15:23:02:315 grammar LogManager.java:25 import 'Int'=1
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'Float'=2
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'Bool'=3
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'String'=4
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'Character'=5
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'var'=6
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'let'=7
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'void'=8
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'true'=9
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'false'=10
2023-08-23 15:23:02:316 grammar LogManager.java:25 import 'print'=11
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'if'=12
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'else'=13
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'while'=14
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'for'=15
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'in'=16
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'switch'=17
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'case'=18
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'default'=19
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'break'=20
2023-08-23 15:23:02:317 grammar LogManager.java:25 import 'return'=21
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'continue'=22
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'guard'=23
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'func'=24
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'nil'=25
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'struct'=26
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'mutating'=27
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'self'=28
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'inout'=29
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'append'=30
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'removeLast'=31
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'remove'=32
2023-08-23 15:23:02:318 grammar LogManager.java:25 import 'at'=33
2023-08-23 15:23:02:319 grammar LogManager.java:25 import 'isEmpty'=34
2023-08-23 15:23:02:319 grammar LogManager.java:25 import 'count'=35
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '!='=39
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '=='=40
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '!'=41
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '||'=42
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '&&'=43
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '='=44
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '>='=45
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '<='=46
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '>'=47
2023-08-23 15:23:02:319 grammar LogManager.java:25 import '<'=48
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '*'=49
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '/'=50
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '+'=51
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '-'=52
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '%'=53
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '('=54
2023-08-23 15:23:02:320 grammar LogManager.java:25 import ')'=55
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '{'=56
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '}'=57
2023-08-23 15:23:02:320 grammar LogManager.java:25 import ':'=58
2023-08-23 15:23:02:320 grammar LogManager.java:25 import '['=59
2023-08-23 15:23:02:320 grammar LogManager.java:25 import ']'=60
2023-08-23 15:23:02:320 grammar LogManager.java:25 import ','=61
2023-08-23 15:23:02:322 grammar LogManager.java:25 tokens={INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, VAR=6, LET=7, VOID=8, TRU=9, FAL=10, PRINT=11, IF=12, ELSE=13, WHILE=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, BREAK=20, RETURN=21, CONTINUE=22, GUARD=23, FUNC=24, NIL=25, STRUCT=26, MUTATING=27, SELF=28, INOUT=29, APPEND=30, REMOVELAST=31, REMOVE=32, AT=33, ISEMPTY=34, COUNT=35, NUMBER=36, STRING=37, ID=38, DIF=39, IG_IG=40, NOT=41, OR=42, AND=43, IG=44, MAY_IG=45, MEN_IG=46, MAYOR=47, MENOR=48, MUL=49, DIV=50, ADD=51, SUB=52, MOD=53, PARIZQ=54, PARDER=55, LLAVEIZQ=56, LLAVEDER=57, D_PTS=58, CORIZQ=59, CORDER=60, COMA=61, WHITESPACE=62, COMMENT=63, LINE_COMMENT=64, 'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'var'=6, 'let'=7, 'void'=8, 'true'=9, 'false'=10, 'print'=11, 'if'=12, 'else'=13, 'while'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'break'=20, 'return'=21, 'continue'=22, 'guard'=23, 'func'=24, 'nil'=25, 'struct'=26, 'mutating'=27, 'self'=28, 'inout'=29, 'append'=30, 'removeLast'=31, 'remove'=32, 'at'=33, 'isEmpty'=34, 'count'=35, '!='=39, '=='=40, '!'=41, '||'=42, '&&'=43, '='=44, '>='=45, '<='=46, '>'=47, '<'=48, '*'=49, '/'=50, '+'=51, '-'=52, '%'=53, '('=54, ')'=55, '{'=56, '}'=57, ':'=58, '['=59, ']'=60, ','=61}
2023-08-23 15:23:02:327 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, VAR=6, LET=7, VOID=8, TRU=9, FAL=10, PRINT=11, IF=12, ELSE=13, WHILE=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, BREAK=20, RETURN=21, CONTINUE=22, GUARD=23, FUNC=24, NIL=25, STRUCT=26, MUTATING=27, SELF=28, INOUT=29, APPEND=30, REMOVELAST=31, REMOVE=32, AT=33, ISEMPTY=34, COUNT=35, NUMBER=36, STRING=37, ID=38, DIF=39, IG_IG=40, NOT=41, OR=42, AND=43, IG=44, MAY_IG=45, MEN_IG=46, MAYOR=47, MENOR=48, MUL=49, DIV=50, ADD=51, SUB=52, MOD=53, PARIZQ=54, PARDER=55, LLAVEIZQ=56, LLAVEDER=57, D_PTS=58, CORIZQ=59, CORDER=60, COMA=61, WHITESPACE=62, COMMENT=63, LINE_COMMENT=64}
2023-08-23 15:23:02:328 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'var'=6, 'let'=7, 'void'=8, 'true'=9, 'false'=10, 'print'=11, 'if'=12, 'else'=13, 'while'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'break'=20, 'return'=21, 'continue'=22, 'guard'=23, 'func'=24, 'nil'=25, 'struct'=26, 'mutating'=27, 'self'=28, 'inout'=29, 'append'=30, 'removeLast'=31, 'remove'=32, 'at'=33, 'isEmpty'=34, 'count'=35, '!='=39, '=='=40, '!'=41, '||'=42, '&&'=43, '='=44, '>='=45, '<='=46, '>'=47, '<'=48, '*'=49, '/'=50, '+'=51, '-'=52, '%'=53, '('=54, ')'=55, '{'=56, '}'=57, ':'=58, '['=59, ']'=60, ','=61}
