2023-08-24 20:08:51:924 grammar LogManager.java:25 before: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE VOID (BLOCK (ALT 'void'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE SUM_IG (BLOCK (ALT '+='))) (RULE SUB_IG (BLOCK (ALT '-='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MOD (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-24 20:08:52:186 grammar LogManager.java:25 after: (LEXER_GRAMMAR SwiftLexer (RULES (RULE INT (BLOCK (ALT 'Int'))) (RULE FLOAT (BLOCK (ALT 'Float'))) (RULE BOOL (BLOCK (ALT 'Bool'))) (RULE STR (BLOCK (ALT 'String'))) (RULE CHAR (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE LET (BLOCK (ALT 'let'))) (RULE VOID (BLOCK (ALT 'void'))) (RULE TRU (BLOCK (ALT 'true'))) (RULE FAL (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE STRUCT (BLOCK (ALT 'struct'))) (RULE MUTATING (BLOCK (ALT 'mutating'))) (RULE SELF (BLOCK (ALT 'self'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'isEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE SUM_IG (BLOCK (ALT '+='))) (RULE SUB_IG (BLOCK (ALT '-='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE MOD (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE D_PTS (BLOCK (ALT ':'))) (RULE CORIZQ (BLOCK (ALT '['))) (RULE CORDER (BLOCK (ALT ']'))) (RULE COMA (BLOCK (ALT ','))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-24 20:09:00:859 grammar LogManager.java:25 before: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT whilestmt { $inst = $whilestmt.whl }) (ALT assignstmt { $inst = $assignstmt.asg }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF expr LLAVEIZQ (= e1 block) LLAVEDER ELSE LLAVEIZQ (= e2 block) LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $e1.blk, $e2.blk) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE ifstmt { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, []interface{}{$ifstmt.ifinst}) }))) (RULE whilestmt (returns interfaces.Instruction whl) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { $whl = instructions.NewWhile($WHILE.line, $WHILE.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }) (ALT LET ID D_PTS types IG expr { $dec = instructions.NewDeclaration($LET.line, $LET.pos, $ID.text, $types.ty, $expr.e) }))) (RULE assignstmt (returns interfaces.Instruction asg) (BLOCK (ALT ID (= op IG) expr { $asg = instructions.NewAssign($ID.line, $ID.pos, $ID.text, $expr.e) }) (ALT expr { $asg = instructions.NewAssign($ID.line, $ID.pos, $ID.text, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT SUB (= opDe expr) {$e = expressions.NewOperation($SUB.line,$SUB.pos,$opDe.e,"NEGACION",nil)}) (ALT (= left expr) (= op (BLOCK (ALT SUB_IG) (ALT SUM_IG))) expr { $e = expressions.NewOperation($op.line, $op.pos, nil, $op.text, $expr.e) }) (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV) (ALT MOD))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 20:09:00:872 grammar LogManager.java:25 after: (COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT whilestmt { $inst = $whilestmt.whl }) (ALT assignstmt { $inst = $assignstmt.asg }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF expr LLAVEIZQ (= e1 block) LLAVEDER ELSE LLAVEIZQ (= e2 block) LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $e1.blk, $e2.blk) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE ifstmt { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, []interface{}{$ifstmt.ifinst}) }))) (RULE whilestmt (returns interfaces.Instruction whl) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { $whl = instructions.NewWhile($WHILE.line, $WHILE.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }) (ALT LET ID D_PTS types IG expr { $dec = instructions.NewDeclaration($LET.line, $LET.pos, $ID.text, $types.ty, $expr.e) }))) (RULE assignstmt (returns interfaces.Instruction asg) (BLOCK (ALT ID (= op IG) expr { $asg = instructions.NewAssign($ID.line, $ID.pos, $ID.text, $expr.e) }) (ALT expr { $asg = instructions.NewAssign($ID.line, $ID.pos, $ID.text, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT SUB (= opDe expr) {$e = expressions.NewOperation($SUB.line,$SUB.pos,$opDe.e,"NEGACION",nil)}) (ALT (= left expr) (= op (SET SUB_IG SUM_IG)) expr { $e = expressions.NewOperation($op.line, $op.pos, nil, $op.text, $expr.e) }) (ALT (= left expr) (= op (SET MUL DIV MOD)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 20:09:00:878 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR SwiftGrammar (OPTIONS (= tokenVocab SwiftLexer)) (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {   
        $code = $block.blk
    }))) (RULE block (returns []interface{} blk) (@ init {
    $blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT ifstmt { $inst = $ifstmt.ifinst }) (ALT declarationstmt { $inst = $declarationstmt.dec }) (ALT whilestmt { $inst = $whilestmt.whl }) (ALT assignstmt { $inst = $assignstmt.asg }))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line,$PRINT.pos,$expr.e)}))) (RULE ifstmt (returns interfaces.Instruction ifinst) (BLOCK (ALT IF expr LLAVEIZQ block LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF expr LLAVEIZQ (= e1 block) LLAVEDER ELSE LLAVEIZQ (= e2 block) LLAVEDER { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $e1.blk, $e2.blk) }) (ALT IF expr LLAVEIZQ block LLAVEDER ELSE ifstmt { $ifinst = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, []interface{}{$ifstmt.ifinst}) }))) (RULE whilestmt (returns interfaces.Instruction whl) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER { $whl = instructions.NewWhile($WHILE.line, $WHILE.pos, $expr.e, $block.blk) }))) (RULE declarationstmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID D_PTS types IG expr { $dec = instructions.NewDeclaration($VAR.line, $VAR.pos, $ID.text, $types.ty, $expr.e) }) (ALT LET ID D_PTS types IG expr { $dec = instructions.NewDeclaration($LET.line, $LET.pos, $ID.text, $types.ty, $expr.e) }))) (RULE assignstmt (returns interfaces.Instruction asg) (BLOCK (ALT ID (= op IG) expr { $asg = instructions.NewAssign($ID.line, $ID.pos, $ID.text, $expr.e) }) (ALT expr { $asg = instructions.NewAssign($ID.line, $ID.pos, $ID.text, $expr.e) }))) (RULE types (returns environment.TipoExpresion ty) (BLOCK (ALT INT { $ty = environment.INTEGER }) (ALT FLOAT { $ty = environment.FLOAT }) (ALT STR { $ty = environment.STRING }) (ALT BOOL { $ty = environment.BOOLEAN }) (ALT CORIZQ CORDER { $ty = environment.ARRAY }))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT SUB (= opDe expr) {$e = expressions.NewOperation($SUB.line,$SUB.pos,$opDe.e,"NEGACION",nil)}) (ALT (= left expr) (= op (SET SUB_IG SUM_IG)) expr { $e = expressions.NewOperation($op.line, $op.pos, nil, $op.text, $expr.e) }) (ALT (= left expr) (= op (SET MUL DIV MOD)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT (= list listArray) { $e = $list.p}) (ALT CORIZQ listParams CORDER { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRU { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT FAL { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) }))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        }))) (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (= list listArray) CORIZQ expr CORDER { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }) (ALT ID { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})))))
2023-08-24 20:09:00:878 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR SwiftGrammarLexer OPTIONS (@ header {
    import "Server2/interfaces"
    import "Server2/environment"
    import "Server2/expressions"
    import "Server2/instructions"
    import "strings"
}) RULES)
2023-08-24 20:09:01:008 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} SUB<tokenIndex=319> opDe=expr<tokenIndex=323,p=16> {$e = expressions.NewOperation($SUB.line,$SUB.pos,$opDe.e,"NEGACION",nil)} 
        | PARIZQ<tokenIndex=481> expr<tokenIndex=483> PARDER<tokenIndex=485> { $e = $expr.e } 
        | list=listArray<tokenIndex=493> { $e = $list.p} 
        | CORIZQ<tokenIndex=499> listParams<tokenIndex=501> CORDER<tokenIndex=503> { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) } 
        | NUMBER<tokenIndex=509>
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=515>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRU<tokenIndex=521> { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) } 
        | FAL<tokenIndex=527> { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 15)}?<p=15> op=(SUB_IG<tokenIndex=336>|SUM_IG<tokenIndex=338>) expr<tokenIndex=341,p=16> { $e = expressions.NewOperation($op.line, $op.pos, nil, $op.text, $expr.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=(MUL<tokenIndex=354>|DIV<tokenIndex=356>|MOD<tokenIndex=358>) right=expr<tokenIndex=363,p=15> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=(ADD<tokenIndex=376>|SUB<tokenIndex=378>) right=expr<tokenIndex=383,p=14> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> op=(MAY_IG<tokenIndex=396>|MAYOR<tokenIndex=398>) right=expr<tokenIndex=403,p=13> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> op=(MEN_IG<tokenIndex=416>|MENOR<tokenIndex=418>) right=expr<tokenIndex=423,p=12> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> op=(IG_IG<tokenIndex=436>|DIF<tokenIndex=438>) right=expr<tokenIndex=443,p=11> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 9)}?<p=9> op=AND<tokenIndex=455> right=expr<tokenIndex=459,p=10> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 8)}?<p=8> op=OR<tokenIndex=471> right=expr<tokenIndex=475,p=9> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-08-24 20:09:01:155 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (SUB (ELEMENT_OPTIONS (= tokenIndex 319))) (= opDe (expr (ELEMENT_OPTIONS (= tokenIndex 323) (= p 16)))) {$e = expressions.NewOperation($SUB.line,$SUB.pos,$opDe.e,"NEGACION",nil)}) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 481))) (expr (ELEMENT_OPTIONS (= tokenIndex 483))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 485))) { $e = $expr.e }) (ALT (= list (listArray (ELEMENT_OPTIONS (= tokenIndex 493)))) { $e = $list.p}) (ALT (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 499))) (listParams (ELEMENT_OPTIONS (= tokenIndex 501))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 503))) { $e = expressions.NewArray($CORIZQ.line, $CORIZQ.pos, $listParams.l) }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 509))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 515))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRU (ELEMENT_OPTIONS (= tokenIndex 521))) { $e = expressions.NewPrimitive($TRU.line, $TRU.pos, true, environment.BOOLEAN) }) (ALT (FAL (ELEMENT_OPTIONS (= tokenIndex 527))) { $e = expressions.NewPrimitive($FAL.line, $FAL.pos, false, environment.BOOLEAN) })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 15)}? (ELEMENT_OPTIONS (= p 15))) (= op (SET (SUB_IG (ELEMENT_OPTIONS (= tokenIndex 336))) (SUM_IG (ELEMENT_OPTIONS (= tokenIndex 338))))) (expr (ELEMENT_OPTIONS (= tokenIndex 341) (= p 16))) { $e = expressions.NewOperation($op.line, $op.pos, nil, $op.text, $expr.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 354))) (DIV (ELEMENT_OPTIONS (= tokenIndex 356))) (MOD (ELEMENT_OPTIONS (= tokenIndex 358))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 363) (= p 15)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 376))) (SUB (ELEMENT_OPTIONS (= tokenIndex 378))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 383) (= p 14)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 396))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 398))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 403) (= p 13)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 416))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 418))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 423) (= p 12)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 436))) (DIF (ELEMENT_OPTIONS (= tokenIndex 438))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 443) (= p 11)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 9)}? (ELEMENT_OPTIONS (= p 9))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 455)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 459) (= p 10)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 8)}? (ELEMENT_OPTIONS (= p 8))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 471)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 475) (= p 9)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-08-24 20:09:01:155 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} expr<tokenIndex=552> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=544> expr<tokenIndex=546> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-08-24 20:09:01:166 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (expr (ELEMENT_OPTIONS (= tokenIndex 552))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 544))) (expr (ELEMENT_OPTIONS (= tokenIndex 546))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-08-24 20:09:01:168 left-recursion LogManager.java:25 listArray returns [interfaces.Expression p]
    :   ( {} ID<tokenIndex=581> { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> CORIZQ<tokenIndex=571> expr<tokenIndex=573> CORDER<tokenIndex=575> { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }
        )*
    ;
2023-08-24 20:09:01:176 grammar LogManager.java:25 added: (RULE listArray (returns interfaces.Expression p) (BLOCK (ALT (BLOCK (ALT {} (ID (ELEMENT_OPTIONS (= tokenIndex 581))) { $p = expressions.NewCallVar($ID.line, $ID.pos, $ID.text)})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (CORIZQ (ELEMENT_OPTIONS (= tokenIndex 571))) (expr (ELEMENT_OPTIONS (= tokenIndex 573))) (CORDER (ELEMENT_OPTIONS (= tokenIndex 575))) { $p = expressions.NewArrayAccess($list.start.GetLine(), $list.start.GetColumn(), $list.p, $expr.e) }))))))
2023-08-24 20:09:01:225 grammar LogManager.java:25 import INT=1
2023-08-24 20:09:01:226 grammar LogManager.java:25 import FLOAT=2
2023-08-24 20:09:01:226 grammar LogManager.java:25 import BOOL=3
2023-08-24 20:09:01:226 grammar LogManager.java:25 import STR=4
2023-08-24 20:09:01:226 grammar LogManager.java:25 import CHAR=5
2023-08-24 20:09:01:226 grammar LogManager.java:25 import VAR=6
2023-08-24 20:09:01:226 grammar LogManager.java:25 import LET=7
2023-08-24 20:09:01:226 grammar LogManager.java:25 import VOID=8
2023-08-24 20:09:01:226 grammar LogManager.java:25 import TRU=9
2023-08-24 20:09:01:226 grammar LogManager.java:25 import FAL=10
2023-08-24 20:09:01:226 grammar LogManager.java:25 import PRINT=11
2023-08-24 20:09:01:226 grammar LogManager.java:25 import IF=12
2023-08-24 20:09:01:226 grammar LogManager.java:25 import ELSE=13
2023-08-24 20:09:01:228 grammar LogManager.java:25 import WHILE=14
2023-08-24 20:09:01:228 grammar LogManager.java:25 import FOR=15
2023-08-24 20:09:01:234 grammar LogManager.java:25 import IN=16
2023-08-24 20:09:01:234 grammar LogManager.java:25 import SWITCH=17
2023-08-24 20:09:01:234 grammar LogManager.java:25 import CASE=18
2023-08-24 20:09:01:234 grammar LogManager.java:25 import DEFAULT=19
2023-08-24 20:09:01:235 grammar LogManager.java:25 import BREAK=20
2023-08-24 20:09:01:235 grammar LogManager.java:25 import RETURN=21
2023-08-24 20:09:01:235 grammar LogManager.java:25 import CONTINUE=22
2023-08-24 20:09:01:235 grammar LogManager.java:25 import GUARD=23
2023-08-24 20:09:01:235 grammar LogManager.java:25 import FUNC=24
2023-08-24 20:09:01:235 grammar LogManager.java:25 import NIL=25
2023-08-24 20:09:01:235 grammar LogManager.java:25 import STRUCT=26
2023-08-24 20:09:01:236 grammar LogManager.java:25 import MUTATING=27
2023-08-24 20:09:01:236 grammar LogManager.java:25 import SELF=28
2023-08-24 20:09:01:236 grammar LogManager.java:25 import INOUT=29
2023-08-24 20:09:01:236 grammar LogManager.java:25 import APPEND=30
2023-08-24 20:09:01:236 grammar LogManager.java:25 import REMOVELAST=31
2023-08-24 20:09:01:236 grammar LogManager.java:25 import REMOVE=32
2023-08-24 20:09:01:236 grammar LogManager.java:25 import AT=33
2023-08-24 20:09:01:236 grammar LogManager.java:25 import ISEMPTY=34
2023-08-24 20:09:01:236 grammar LogManager.java:25 import COUNT=35
2023-08-24 20:09:01:237 grammar LogManager.java:25 import NUMBER=36
2023-08-24 20:09:01:237 grammar LogManager.java:25 import STRING=37
2023-08-24 20:09:01:237 grammar LogManager.java:25 import ID=38
2023-08-24 20:09:01:237 grammar LogManager.java:25 import DIF=39
2023-08-24 20:09:01:237 grammar LogManager.java:25 import IG_IG=40
2023-08-24 20:09:01:237 grammar LogManager.java:25 import NOT=41
2023-08-24 20:09:01:237 grammar LogManager.java:25 import OR=42
2023-08-24 20:09:01:237 grammar LogManager.java:25 import AND=43
2023-08-24 20:09:01:237 grammar LogManager.java:25 import IG=44
2023-08-24 20:09:01:237 grammar LogManager.java:25 import MAY_IG=45
2023-08-24 20:09:01:237 grammar LogManager.java:25 import MEN_IG=46
2023-08-24 20:09:01:238 grammar LogManager.java:25 import SUM_IG=47
2023-08-24 20:09:01:238 grammar LogManager.java:25 import SUB_IG=48
2023-08-24 20:09:01:238 grammar LogManager.java:25 import MAYOR=49
2023-08-24 20:09:01:238 grammar LogManager.java:25 import MENOR=50
2023-08-24 20:09:01:240 grammar LogManager.java:25 import MUL=51
2023-08-24 20:09:01:240 grammar LogManager.java:25 import DIV=52
2023-08-24 20:09:01:241 grammar LogManager.java:25 import ADD=53
2023-08-24 20:09:01:241 grammar LogManager.java:25 import SUB=54
2023-08-24 20:09:01:241 grammar LogManager.java:25 import MOD=55
2023-08-24 20:09:01:242 grammar LogManager.java:25 import PARIZQ=56
2023-08-24 20:09:01:242 grammar LogManager.java:25 import PARDER=57
2023-08-24 20:09:01:243 grammar LogManager.java:25 import LLAVEIZQ=58
2023-08-24 20:09:01:243 grammar LogManager.java:25 import LLAVEDER=59
2023-08-24 20:09:01:243 grammar LogManager.java:25 import D_PTS=60
2023-08-24 20:09:01:243 grammar LogManager.java:25 import CORIZQ=61
2023-08-24 20:09:01:243 grammar LogManager.java:25 import CORDER=62
2023-08-24 20:09:01:243 grammar LogManager.java:25 import COMA=63
2023-08-24 20:09:01:243 grammar LogManager.java:25 import WHITESPACE=64
2023-08-24 20:09:01:243 grammar LogManager.java:25 import COMMENT=65
2023-08-24 20:09:01:243 grammar LogManager.java:25 import LINE_COMMENT=66
2023-08-24 20:09:01:244 grammar LogManager.java:25 import 'Int'=1
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'Float'=2
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'Bool'=3
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'String'=4
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'Character'=5
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'var'=6
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'let'=7
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'void'=8
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'true'=9
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'false'=10
2023-08-24 20:09:01:245 grammar LogManager.java:25 import 'print'=11
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'if'=12
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'else'=13
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'while'=14
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'for'=15
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'in'=16
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'switch'=17
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'case'=18
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'default'=19
2023-08-24 20:09:01:246 grammar LogManager.java:25 import 'break'=20
2023-08-24 20:09:01:248 grammar LogManager.java:25 import 'return'=21
2023-08-24 20:09:01:248 grammar LogManager.java:25 import 'continue'=22
2023-08-24 20:09:01:248 grammar LogManager.java:25 import 'guard'=23
2023-08-24 20:09:01:248 grammar LogManager.java:25 import 'func'=24
2023-08-24 20:09:01:249 grammar LogManager.java:25 import 'nil'=25
2023-08-24 20:09:01:250 grammar LogManager.java:25 import 'struct'=26
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'mutating'=27
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'self'=28
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'inout'=29
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'append'=30
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'removeLast'=31
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'remove'=32
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'at'=33
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'isEmpty'=34
2023-08-24 20:09:01:251 grammar LogManager.java:25 import 'count'=35
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '!='=39
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '=='=40
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '!'=41
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '||'=42
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '&&'=43
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '='=44
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '>='=45
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '<='=46
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '+='=47
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '-='=48
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '>'=49
2023-08-24 20:09:01:252 grammar LogManager.java:25 import '<'=50
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '*'=51
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '/'=52
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '+'=53
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '-'=54
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '%'=55
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '('=56
2023-08-24 20:09:01:253 grammar LogManager.java:25 import ')'=57
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '{'=58
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '}'=59
2023-08-24 20:09:01:253 grammar LogManager.java:25 import ':'=60
2023-08-24 20:09:01:253 grammar LogManager.java:25 import '['=61
2023-08-24 20:09:01:253 grammar LogManager.java:25 import ']'=62
2023-08-24 20:09:01:253 grammar LogManager.java:25 import ','=63
2023-08-24 20:09:01:256 grammar LogManager.java:25 tokens={INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, VAR=6, LET=7, VOID=8, TRU=9, FAL=10, PRINT=11, IF=12, ELSE=13, WHILE=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, BREAK=20, RETURN=21, CONTINUE=22, GUARD=23, FUNC=24, NIL=25, STRUCT=26, MUTATING=27, SELF=28, INOUT=29, APPEND=30, REMOVELAST=31, REMOVE=32, AT=33, ISEMPTY=34, COUNT=35, NUMBER=36, STRING=37, ID=38, DIF=39, IG_IG=40, NOT=41, OR=42, AND=43, IG=44, MAY_IG=45, MEN_IG=46, SUM_IG=47, SUB_IG=48, MAYOR=49, MENOR=50, MUL=51, DIV=52, ADD=53, SUB=54, MOD=55, PARIZQ=56, PARDER=57, LLAVEIZQ=58, LLAVEDER=59, D_PTS=60, CORIZQ=61, CORDER=62, COMA=63, WHITESPACE=64, COMMENT=65, LINE_COMMENT=66, 'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'var'=6, 'let'=7, 'void'=8, 'true'=9, 'false'=10, 'print'=11, 'if'=12, 'else'=13, 'while'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'break'=20, 'return'=21, 'continue'=22, 'guard'=23, 'func'=24, 'nil'=25, 'struct'=26, 'mutating'=27, 'self'=28, 'inout'=29, 'append'=30, 'removeLast'=31, 'remove'=32, 'at'=33, 'isEmpty'=34, 'count'=35, '!='=39, '=='=40, '!'=41, '||'=42, '&&'=43, '='=44, '>='=45, '<='=46, '+='=47, '-='=48, '>'=49, '<'=50, '*'=51, '/'=52, '+'=53, '-'=54, '%'=55, '('=56, ')'=57, '{'=58, '}'=59, ':'=60, '['=61, ']'=62, ','=63}
2023-08-24 20:09:01:269 semantics LogManager.java:25 tokens={EOF=-1, INT=1, FLOAT=2, BOOL=3, STR=4, CHAR=5, VAR=6, LET=7, VOID=8, TRU=9, FAL=10, PRINT=11, IF=12, ELSE=13, WHILE=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, BREAK=20, RETURN=21, CONTINUE=22, GUARD=23, FUNC=24, NIL=25, STRUCT=26, MUTATING=27, SELF=28, INOUT=29, APPEND=30, REMOVELAST=31, REMOVE=32, AT=33, ISEMPTY=34, COUNT=35, NUMBER=36, STRING=37, ID=38, DIF=39, IG_IG=40, NOT=41, OR=42, AND=43, IG=44, MAY_IG=45, MEN_IG=46, SUM_IG=47, SUB_IG=48, MAYOR=49, MENOR=50, MUL=51, DIV=52, ADD=53, SUB=54, MOD=55, PARIZQ=56, PARDER=57, LLAVEIZQ=58, LLAVEDER=59, D_PTS=60, CORIZQ=61, CORDER=62, COMA=63, WHITESPACE=64, COMMENT=65, LINE_COMMENT=66}
2023-08-24 20:09:01:271 semantics LogManager.java:25 strings={'Int'=1, 'Float'=2, 'Bool'=3, 'String'=4, 'Character'=5, 'var'=6, 'let'=7, 'void'=8, 'true'=9, 'false'=10, 'print'=11, 'if'=12, 'else'=13, 'while'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'break'=20, 'return'=21, 'continue'=22, 'guard'=23, 'func'=24, 'nil'=25, 'struct'=26, 'mutating'=27, 'self'=28, 'inout'=29, 'append'=30, 'removeLast'=31, 'remove'=32, 'at'=33, 'isEmpty'=34, 'count'=35, '!='=39, '=='=40, '!'=41, '||'=42, '&&'=43, '='=44, '>='=45, '<='=46, '+='=47, '-='=48, '>'=49, '<'=50, '*'=51, '/'=52, '+'=53, '-'=54, '%'=55, '('=56, ')'=57, '{'=58, '}'=59, ':'=60, '['=61, ']'=62, ','=63}
